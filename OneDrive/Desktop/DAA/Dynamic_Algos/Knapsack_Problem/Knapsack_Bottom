def knap_sack_aux(v, w, n, capacity, sack, keep):
    for i in range(1, n + 1):
        for j in range(capacity + 1):
            if w[i - 1] <= j:
                sack[i][j] = max(sack[i - 1][j], v[i - 1] + sack[i - 1][j - w[i - 1]])
                keep[i][j] = 1
            else:
                sack[i][j] = sack[i - 1][j]
                keep[i][j] = 0
    return sack

def knap_sack(v, w, n, capacity):
    sack = {i: {} for i in range(n + 1)}
    keep = {i: {} for i in range(n + 1)}

    for i in range(n + 1):
        for j in range(capacity + 1):
            sack[i][j] = 0

    return knap_sack_aux(v, w, n, capacity, sack, keep), keep

def print_optimal_solution(w, n, capacity, keep):
    while n > 0:
        if keep[n][capacity] == 1:
            print(n,  end=" ")
            capacity -= w[n - 1]
        n -= 1
